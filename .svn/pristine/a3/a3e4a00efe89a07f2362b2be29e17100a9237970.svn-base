using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Extensions;
using MongoDB.Bson;

namespace AI {
    public class FSM {
        private Dictionary<string, IState> cachedStates;
        private static FSM _fsm = null;

        public IState state {
            get;
            set;
        }

        public IState globalState {
            get;
            set;
        }

        public IState previousState { //for blip states mostly
            get;
             set;
        }

        //public Character.NPC Actor {
        //    get;
        //    set;
        //}

        private FSM() { 
            cachedStates = new Dictionary<string, IState>();
            CacheStates();
        }

        public static FSM GetInstance() {
            return _fsm ?? (_fsm = new FSM());
        }

        private void CacheStates() {
            var totalerTypes = System.Reflection.Assembly.GetExecutingAssembly().GetTypes().Where(t => typeof(IState).IsAssignableFrom(t) && t.IsClass == true);
            foreach (Type totalerType in totalerTypes) {
                cachedStates.Add(totalerType.Name, (IState)totalerType.GetMethod("GetState").Invoke(totalerType, null)); 
            }    
        }

        public static bool ContinueWithThisState() {
            if (Extensions.RandomNumber.GetRandomNumber().NextNumber(0, 6) == 2 || Extensions.RandomNumber.GetRandomNumber().NextNumber(0, 6) == 5 || Extensions.RandomNumber.GetRandomNumber().NextNumber(0, 6) == 0) {//if this hits then we are going to stop walking and do something else like say something
                return false;
            }
            return true;
        }


        public IState GetStateFromName(string stateName) {
            if (cachedStates.ContainsKey(stateName)){
                return cachedStates[stateName];
            }

            return null;
        }

        public void ChangeState(IState newState, Character.NPC Actor) {
            if (state != null && newState != null) {
                state.Exit(Actor);
                previousState = state;
                state = newState;
                state.Enter(Actor);
                Actor.Save();
            }
        }

        public void RevertState() {
            IState temp = state;
            if (previousState != null) {
                state = previousState;
            }
            else {
                state = Wander.GetState(); //if no previous state we'll just default to wandering around for now
            }

            previousState = temp;
            temp = null;
        }

        public void Update(Character.NPC Actor) {
            if (state != null) {
                state.Execute(Actor);
            }
            if (globalState != null) {
                globalState.Execute(Actor);
            }
        }

        public void InterpretMessage(string message, Character.NPC Actor) {
            string[] tokenized = message.Split(' ');
            //someone performed an action directed at the NPC and it wasn't just speaking
            if (message.ToUpper().Contains("YOU") && message.ToUpper().Contains("SAYS")) {

            }
            //someone probably emoted towards the NPC
            else if(message.ToUpper().Contains(Actor.FirstName.ToUpper())){
            }
            //someone said something let's see if it triggers something in the NPC
            else if (message.ToUpper().Contains("SAYS")) {
            }

        }
    }

    public class Scripts {
        //do I need a list of players and dictionaries?  Wouldn't this NPC just respond to each message in the message queue and 
        //run the script for that person until the script finishes? It would be a bunch of speech and some emotes really.

        private List<string> CurrentQuest { //quest the NPC can give to the player that has not been completed or is in progress
            get;
            set;
        }

        private int QuestStep {  //the current quest a player is assigned to
            get;
            set;
        }

        private BsonDocument Script {
            get;
            set;
        }

        public Scripts() { }

        private void GetCurrentQuests(string npcID, string playerID, BsonArray playerQuestsInProgress){
            //get the list of available quests the NPC can give
            //may need to modify this in the future what if an NPC gets killed?  If they respawn they will have a new ID.
            //maybe some quests qet lost when an NPC dies and maybe some other NPC's can't die only get knocked unconcious. (gonna need a flag for that)
            BsonArray availableQuests = MongoUtils.MongoData.GetCollection("Characters", "NPCQuests").FindOneAs<BsonArray>(MongoDB.Driver.Builders.Query.EQ("_id", npcID));
            
            //I'm going to want to keep the in-progress and completed quests under the Player information
            //need to find all the in progress quests this player has with this NPC that way they can have multiple quests from the same NPC
            //and not have to visit the NPC once for every single quest he can give.
            foreach (BsonDocument quest in availableQuests) {
                if (playerQuestsInProgress.Contains(quest["ID"])) { //if the player has an in-progress quest that belongs to this NPC load it.
                    CurrentQuest.Add(quest["ID"].AsString);
                }
            }

        }

        public void LoadCurrentQuest(string npcId, string playerId) {
            
            


        }

        public void SaveActiveQuests(string npcId) {
            BsonArray activeQuests = new BsonArray();

            BsonDocument quest = new BsonDocument();
            
            activeQuests.Add(quest);


            BsonDocument result = new BsonDocument();
            result.Add("_id", npcId);
            result.Add("ActiveQuests", activeQuests);

            MongoUtils.MongoData.GetCollection("NPCS", "Quests").Save(result);
        }

        public void AddAQuester(string playerId) {
            
        }

        private void RemoveAQuester(string playerId) {
            
        }

        private void IncreaseStep(string playerId) {
            
        }

        public void PerformScriptstep() {
            //TODO: I need to store the ID of the actual script that is going to be used for this quest unless NPCS are going to have just one script
            //that could possibly be several different quests.  Can't start the next one until you finish the previous one.  That sounds lame and not cool
            //I would rather be able to have the quest the Quester is on and the step for that quest.  Two dictionaries should fix that.
        }
    }
    
}

